<!DOCTYPE html>
<!--
CUSTOMIZE:
- Replace "Katto" and the nickname lines in the first card (headline, subtitle, fun line) to personalize.
- Update the success headline/line in the second card for different wording if you want.
- Paste your video link into the VIDEO_URL constant in the script at the bottom.

GITHUB PAGES DEPLOY:
1. Create a new GitHub repo (public or private).
2. Upload this index.html to the repo root and commit it.
3. In Settings ‚Üí Pages, choose the main branch and / (root) as the source.
4. Save; after it builds, open the provided Pages URL.
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Valentine for Katto</title>
  <style>
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --rose-1: #fff2f5;
      --rose-2: #ffe2eb;
      --rose-3: #ffd3e0;
      --cream: #fff8f5;
      --ink: #5a3a3a;
      --shadow: rgba(126, 70, 90, 0.25);
      --glass: rgba(255, 255, 255, 0.45);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      min-height: 100svh;
      background: var(--cream);
      color: var(--ink);
      font-family: "Segoe UI", "SF Pro Text", -apple-system, system-ui, "Helvetica Neue", Arial, sans-serif;
      padding: calc(20px + var(--safe-top)) calc(20px + var(--safe-right)) calc(20px + var(--safe-bottom)) calc(20px + var(--safe-left));
      overflow: hidden;
    }

    .bg-gradient,
    .bg-paws,
    #bgCanvas {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    .bg-gradient {
      background:
        radial-gradient(900px 600px at 15% 20%, rgba(255, 222, 232, 0.85), transparent 60%),
        radial-gradient(800px 520px at 80% 30%, rgba(255, 214, 226, 0.8), transparent 65%),
        linear-gradient(120deg, var(--rose-1) 0%, var(--rose-2) 45%, var(--cream) 100%);
      animation: drift 26s ease-in-out infinite;
      filter: saturate(0.95);
    }

    .bg-paws {
      opacity: 0.35;
      background-image:
        radial-gradient(circle at 18px 18px, rgba(255, 186, 198, 0.18) 0 7px, transparent 8px),
        radial-gradient(circle at 32px 12px, rgba(255, 186, 198, 0.18) 0 3.5px, transparent 4px),
        radial-gradient(circle at 40px 22px, rgba(255, 186, 198, 0.18) 0 3.5px, transparent 4px),
        radial-gradient(circle at 26px 26px, rgba(255, 186, 198, 0.18) 0 3.5px, transparent 4px);
      background-size: 120px 120px;
      background-position: 10px 20px;
      mix-blend-mode: multiply;
    }

    @keyframes drift {
      0% {
        transform: translate3d(0, 0, 0) scale(1);
      }
      50% {
        transform: translate3d(-4%, -2%, 0) scale(1.03);
      }
      100% {
        transform: translate3d(0, 0, 0) scale(1);
      }
    }

    .app {
      position: relative;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      opacity: 0;
      transform: scale(0.98) translateY(8px);
      transition: opacity 380ms ease, transform 380ms ease;
      pointer-events: none;
      perspective: 1200px;
    }

    #screen-ask {
      opacity: 1;
      transform: scale(1) translateY(0);
      pointer-events: auto;
    }

    body.state-yes #screen-ask {
      opacity: 0;
      transform: scale(0.96) translateY(10px);
      pointer-events: none;
    }

    body.state-yes #screen-yes {
      opacity: 1;
      transform: scale(1) translateY(0);
      pointer-events: auto;
    }

    .card {
      --tilt-x: 0deg;
      --tilt-y: 0deg;
      position: relative;
      width: min(92vw, 720px);
      padding: 38px 34px 32px;
      border-radius: 28px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.72), rgba(255, 244, 249, 0.42));
      border: 1px solid rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(18px);
      box-shadow:
        0 20px 60px var(--shadow),
        inset 0 1px 0 rgba(255, 255, 255, 0.85),
        inset 0 -12px 30px rgba(255, 204, 220, 0.16);
      text-align: center;
      transform-style: preserve-3d;
      transform: translateZ(0) rotateX(var(--tilt-x)) rotateY(var(--tilt-y));
      transition: transform 220ms ease;
    }

    .card--wide {
      padding-bottom: 26px;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background:
        radial-gradient(140px 90px at 18% 10%, rgba(255, 255, 255, 0.85), transparent 70%),
        radial-gradient(240px 180px at 90% 20%, rgba(255, 221, 232, 0.55), transparent 70%);
      opacity: 0.6;
      transform: translateZ(1px);
      pointer-events: none;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      opacity: 0.6;
      pointer-events: none;
    }

    .cat-ears {
      position: absolute;
      top: -18px;
      left: 50%;
      width: 90px;
      height: 36px;
      transform: translateX(-50%);
      pointer-events: none;
    }

    .cat-ears::before,
    .cat-ears::after {
      content: "";
      position: absolute;
      bottom: 0;
      width: 24px;
      height: 24px;
      background: rgba(255, 255, 255, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.85);
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
      filter: drop-shadow(0 4px 6px rgba(120, 70, 90, 0.18));
    }

    .cat-ears::before {
      left: 6px;
      transform: rotate(-4deg);
    }

    .cat-ears::after {
      right: 6px;
      transform: rotate(4deg);
    }

    h1 {
      margin: 14px 0 14px;
      font-size: clamp(1.6rem, 3.5vw, 2.4rem);
      line-height: 1.2;
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, "Times New Roman", ui-serif, serif;
      letter-spacing: 0.3px;
    }

    .subtitle {
      margin: 0 0 10px;
      font-size: clamp(1rem, 2.4vw, 1.15rem);
      opacity: 0.85;
    }

    .tease {
      margin: 0 0 22px;
      font-size: 0.98rem;
      opacity: 0.75;
    }

    .button-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      min-height: 64px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      font-size: 1rem;
      min-height: 44px;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 160ms ease, background 240ms ease;
      font-family: "Segoe UI", "SF Pro Text", -apple-system, system-ui, "Helvetica Neue", Arial, sans-serif;
    }

    .btn:focus-visible {
      outline: 3px solid rgba(255, 160, 185, 0.8);
      outline-offset: 3px;
    }

    .btn--yes {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, #ffb2c4, #ffd4e1);
      color: #5a2b3a;
      box-shadow: 0 10px 26px rgba(255, 150, 178, 0.35);
    }

    .btn--yes:hover {
      transform: translateY(-2px) scale(1.04);
      box-shadow: 0 14px 30px rgba(255, 140, 175, 0.45), 0 0 18px rgba(255, 190, 210, 0.55);
      background: linear-gradient(135deg, #ff9fba, #ffdbe6);
    }

    .btn--yes::before {
      content: "";
      position: absolute;
      inset: -40%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.85), transparent 60%);
      opacity: 0;
      transform: translateY(20%) scale(0.9);
      transition: opacity 220ms ease, transform 220ms ease;
      pointer-events: none;
    }

    .btn--yes:hover::before {
      opacity: 0.9;
      transform: translateY(0) scale(1);
    }

    .btn--yes:active {
      transform: translateY(0) scale(1.01);
    }

    .btn--no {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate3d(0, 0, 0);
      background: rgba(255, 255, 255, 0.65);
      color: #7a4a58;
      border: 1px solid rgba(255, 255, 255, 0.9);
      box-shadow: 0 8px 18px rgba(110, 80, 90, 0.18);
      transition: left var(--no-move-duration, 160ms) ease-out, top var(--no-move-duration, 160ms) ease-out, transform 120ms ease-out;
      z-index: 3;
      opacity: 0;
    }

    body.state-yes .btn--no {
      opacity: 0;
      pointer-events: none;
    }

    .btn--back {
      margin-top: 18px;
      background: linear-gradient(135deg, #ffd7e2, #fff1f6);
      color: #5a2b3a;
      box-shadow: 0 10px 22px rgba(255, 150, 178, 0.25);
    }

    .micro-msg {
      position: absolute;
      top: 18px;
      right: 22px;
      font-size: 0.92rem;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 160ms ease, transform 160ms ease;
      color: #7a4a58;
      pointer-events: none;
    }

    .micro-msg.show {
      opacity: 0.9;
      transform: translateY(0);
    }

    .video-wrap {
      margin-top: 16px;
      width: 100%;
      aspect-ratio: 16 / 9;
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 14px 30px rgba(120, 70, 90, 0.2);
    }

    .video-wrap iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      border-radius: 18px;
    }

    .video-notice {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      text-align: center;
      font-size: 0.98rem;
      color: #6c4652;
    }

    @media (max-width: 640px) {
      .card {
        padding: 30px 22px 26px;
      }

      .micro-msg {
        top: 12px;
        right: 16px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .bg-gradient {
        animation: none;
      }

      .btn,
      .screen {
        transition: none;
      }

      .card {
        transform: none;
      }

      #bgCanvas {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="bg-gradient" aria-hidden="true"></div>
  <div class="bg-paws" aria-hidden="true"></div>
  <canvas id="bgCanvas" aria-hidden="true"></canvas>

  <main class="app" role="main">
    <section id="screen-ask" class="screen screen--ask" aria-hidden="false">
      <div class="card">
        <div class="cat-ears" aria-hidden="true"></div>
        <h1>Will you be my Valentine, Katto? üíòüêæ</h1>
        <p class="subtitle">Shona‚Äôs Katze deserves a magical day ‚ú®</p>
        <p class="tease">I already know your answer‚Ä¶ but I‚Äôll let you click it üòº</p>

        <div class="button-row">
          <button id="yesBtn" class="btn btn--yes">Yes üíñ</button>
          <button id="noBtn" class="btn btn--no" tabindex="-1" aria-hidden="true">No üôà</button>
        </div>

        <div id="microMsg" class="micro-msg" aria-live="polite"></div>
      </div>
    </section>

    <section id="screen-yes" class="screen screen--yes" aria-hidden="true">
      <div class="card card--wide">
        <div class="cat-ears" aria-hidden="true"></div>
        <h1>Yay!! üíû Of course you said yes, my Katto üòÑ</h1>
        <p class="subtitle">I knew it. I always know it. You‚Äôre predictable in the cutest way üòåüêæ</p>

        <div class="video-wrap">
          <div id="videoNotice" class="video-notice">Paste your video link into the VIDEO_URL constant in the script to show it here.</div>
          <iframe id="videoFrame" title="Valentine video" loading="lazy" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>

        <button id="backBtn" class="btn btn--back">Replay</button>
      </div>
    </section>
  </main>

  <script>
    const VIDEO_URL = "PASTE_VIDEO_LINK_HERE";

    const body = document.body;
    const yesBtn = document.getElementById("yesBtn");
    const noBtn = document.getElementById("noBtn");
    const backBtn = document.getElementById("backBtn");
    const screenAsk = document.getElementById("screen-ask");
    const screenYes = document.getElementById("screen-yes");
    const microMsg = document.getElementById("microMsg");
    const videoFrame = document.getElementById("videoFrame");
    const videoNotice = document.getElementById("videoNotice");
    const askCard = screenAsk.querySelector(".card");

    const reduceMotionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
    let isReducedMotion = reduceMotionQuery.matches;
    if (isReducedMotion) {
      body.classList.add("reduce-motion");
    }

    function updateVideo() {
      if (!VIDEO_URL || VIDEO_URL.indexOf("PASTE_VIDEO_LINK_HERE") !== -1) {
        videoNotice.hidden = false;
        videoFrame.hidden = true;
      } else {
        videoFrame.src = VIDEO_URL;
        videoFrame.hidden = false;
        videoNotice.hidden = true;
      }
    }

    updateVideo();

    const tiltCards = document.querySelectorAll(".card");
    const tiltConfigs = new WeakMap();

    function attachTilt(card) {
      const config = {
        targetX: 0,
        targetY: 0,
        currentX: 0,
        currentY: 0,
        rafId: null
      };
      tiltConfigs.set(card, config);
      const maxTilt = 6;

      function animateTilt() {
        if (isReducedMotion) {
          card.style.setProperty("--tilt-x", "0deg");
          card.style.setProperty("--tilt-y", "0deg");
          config.rafId = null;
          return;
        }
        const ease = 0.12;
        config.currentX += (config.targetX - config.currentX) * ease;
        config.currentY += (config.targetY - config.currentY) * ease;
        card.style.setProperty("--tilt-x", config.currentX.toFixed(2) + "deg");
        card.style.setProperty("--tilt-y", config.currentY.toFixed(2) + "deg");
        if (Math.abs(config.currentX - config.targetX) < 0.05 && Math.abs(config.currentY - config.targetY) < 0.05) {
          config.rafId = null;
          return;
        }
        config.rafId = requestAnimationFrame(animateTilt);
      }

      function setTargetFromEvent(event) {
        if (isReducedMotion) {
          return;
        }
        const rect = card.getBoundingClientRect();
        const relX = (event.clientX - rect.left) / rect.width - 0.5;
        const relY = (event.clientY - rect.top) / rect.height - 0.5;
        config.targetY = relX * maxTilt * 2;
        config.targetX = -relY * maxTilt * 2;
        if (!config.rafId) {
          config.rafId = requestAnimationFrame(animateTilt);
        }
      }

      card.addEventListener("pointermove", setTargetFromEvent);
      card.addEventListener("pointerleave", () => {
        config.targetX = 0;
        config.targetY = 0;
        if (!config.rafId) {
          config.rafId = requestAnimationFrame(animateTilt);
        }
      });
    }

    tiltCards.forEach(attachTilt);

    function setScreen(isYes) {
      if (isYes) {
        body.classList.add("state-yes");
        screenAsk.setAttribute("aria-hidden", "true");
        screenYes.setAttribute("aria-hidden", "false");
        backBtn.focus({ preventScroll: true });
        startShower();
      } else {
        body.classList.remove("state-yes");
        screenAsk.setAttribute("aria-hidden", "false");
        screenYes.setAttribute("aria-hidden", "true");
        yesBtn.focus({ preventScroll: true });
        placeNoButton(true);
        clearShower();
      }
    }

    yesBtn.addEventListener("click", () => {
      spawnBurstFromYes();
      setScreen(true);
    });

    backBtn.addEventListener("click", () => {
      setScreen(false);
    });

    const microMessages = ["Nice try üòº", "Not today üôÉ", "Your cursor can‚Äôt catch me üêæ"];
    let noAttempts = 0;
    let lastJumpTime = 0;
    let lastPointer = { x: 0, y: 0 };

    function showMicroMessage() {
      microMsg.textContent = microMessages[Math.floor(Math.random() * microMessages.length)];
      microMsg.classList.remove("show");
      void microMsg.offsetWidth;
      microMsg.classList.add("show");
    }

    function placeNoButton(force, avoidPoint) {
      if (body.classList.contains("state-yes")) {
        return;
      }

      const rect = noBtn.getBoundingClientRect();
      const yesRect = yesBtn.getBoundingClientRect();
      const cardRect = askCard.getBoundingClientRect();
      const cardStyles = getComputedStyle(askCard);
      const borderLeft = parseFloat(cardStyles.borderLeftWidth) || 0;
      const borderTop = parseFloat(cardStyles.borderTopWidth) || 0;
      const cardWidth = askCard.clientWidth;
      const cardHeight = askCard.clientHeight;
      const cardOrigin = {
        x: cardRect.left + borderLeft,
        y: cardRect.top + borderTop
      };
      const margin = 12;

      const minX = margin;
      const maxX = Math.max(minX, cardWidth - rect.width - margin);
      const minY = margin;
      const maxY = Math.max(minY, cardHeight - rect.height - margin);

      const yesCenter = {
        x: yesRect.left - cardRect.left - borderLeft + yesRect.width / 2,
        y: yesRect.top - cardRect.top - borderTop + yesRect.height / 2
      };

      const baseGap = 16;
      const minDistanceBase = yesRect.width / 2 + rect.width / 2 + baseGap;
      const minDistance = minDistanceBase + Math.min(noAttempts, 12) * 4;
      const avoidLocal = avoidPoint ? {
        x: avoidPoint.x - cardOrigin.x,
        y: avoidPoint.y - cardOrigin.y
      } : null;
      const pointerAvoid = avoidLocal ? 160 + Math.min(noAttempts, 12) * 8 : 0;
      let x = minX;
      let y = minY;
      let found = false;

      if (noAttempts === 0 && force) {
        const preferredCenters = [
          { x: yesCenter.x + yesRect.width / 2 + rect.width / 2 + baseGap, y: yesCenter.y },
          { x: yesCenter.x - yesRect.width / 2 - rect.width / 2 - baseGap, y: yesCenter.y },
          { x: yesCenter.x, y: yesCenter.y + yesRect.height / 2 + rect.height / 2 + 12 },
          { x: yesCenter.x, y: yesCenter.y - yesRect.height / 2 - rect.height / 2 - 12 }
        ];

        for (const center of preferredCenters) {
          const candidateX = center.x - rect.width / 2;
          const candidateY = center.y - rect.height / 2;
          if (candidateX < minX || candidateX > maxX || candidateY < minY || candidateY > maxY) {
            continue;
          }
          const dist = Math.hypot(center.x - yesCenter.x, center.y - yesCenter.y);
          if (dist < minDistanceBase) {
            continue;
          }
          if (avoidLocal && Math.hypot(center.x - avoidLocal.x, center.y - avoidLocal.y) < pointerAvoid) {
            continue;
          }
          x = candidateX;
          y = candidateY;
          found = true;
          break;
        }
      }

      for (let i = 0; i < 40 && !found; i += 1) {
        const candidateX = minX + Math.random() * (maxX - minX);
        const candidateY = minY + Math.random() * (maxY - minY);
        const center = {
          x: candidateX + rect.width / 2,
          y: candidateY + rect.height / 2
        };
        const dist = Math.hypot(center.x - yesCenter.x, center.y - yesCenter.y);
        if (dist < minDistance) {
          continue;
        }
        if (avoidLocal && Math.hypot(center.x - avoidLocal.x, center.y - avoidLocal.y) < pointerAvoid) {
          continue;
        }
        x = candidateX;
        y = candidateY;
        found = true;
        break;
      }

      if (!found) {
        const corners = [
          { x: minX, y: minY },
          { x: maxX, y: minY },
          { x: minX, y: maxY },
          { x: maxX, y: maxY }
        ];
        corners.sort((a, b) => {
          const centerA = { x: a.x + rect.width / 2, y: a.y + rect.height / 2 };
          const centerB = { x: b.x + rect.width / 2, y: b.y + rect.height / 2 };
          const distYesA = Math.hypot(centerA.x - yesCenter.x, centerA.y - yesCenter.y);
          const distYesB = Math.hypot(centerB.x - yesCenter.x, centerB.y - yesCenter.y);
          const distAvoidA = avoidLocal ? Math.hypot(centerA.x - avoidLocal.x, centerA.y - avoidLocal.y) : 0;
          const distAvoidB = avoidLocal ? Math.hypot(centerB.x - avoidLocal.x, centerB.y - avoidLocal.y) : 0;
          const scoreA = distYesA + distAvoidA * 1.2;
          const scoreB = distYesB + distAvoidB * 1.2;
          return scoreB - scoreA;
        });
        x = corners[0].x;
        y = corners[0].y;
      }

      noBtn.style.left = x + "px";
      noBtn.style.top = y + "px";
      noBtn.style.opacity = "1";
    }

    function attemptJump(point) {
      if (body.classList.contains("state-yes")) {
        return;
      }
      const now = performance.now();
      if (now - lastJumpTime < 120) {
        return;
      }
      lastJumpTime = now;
      noAttempts += 1;
      const speed = Math.max(60, 160 - Math.min(noAttempts, 12) * 6);
      noBtn.style.setProperty("--no-move-duration", speed + "ms");
      const avoidPoint = point || lastPointer;
      placeNoButton(false, avoidPoint);
      showMicroMessage();

      requestAnimationFrame(() => {
        const rect = noBtn.getBoundingClientRect();
        if (avoidPoint.x >= rect.left && avoidPoint.x <= rect.right && avoidPoint.y >= rect.top && avoidPoint.y <= rect.bottom) {
          placeNoButton(false, avoidPoint);
        }
      });
    }

    noBtn.addEventListener("pointerenter", (event) => {
      attemptJump({ x: event.clientX, y: event.clientY });
    });
    noBtn.addEventListener("pointerdown", (event) => {
      event.preventDefault();
      event.stopPropagation();
      attemptJump({ x: event.clientX, y: event.clientY });
    });
    noBtn.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      attemptJump({ x: event.clientX, y: event.clientY });
    });

    noBtn.addEventListener("touchstart", (event) => {
      const touch = event.touches[0];
      event.preventDefault();
      event.stopPropagation();
      if (touch) {
        attemptJump({ x: touch.clientX, y: touch.clientY });
      } else {
        attemptJump();
      }
    }, { passive: false });

    window.addEventListener("pointermove", (event) => {
      lastPointer = { x: event.clientX, y: event.clientY };
    });

    document.addEventListener("focusin", (event) => {
      if (event.target === noBtn) {
        yesBtn.focus({ preventScroll: true });
        attemptJump();
      }
    });

    window.addEventListener("resize", () => {
      placeNoButton(true);
    });

    requestAnimationFrame(() => {
      placeNoButton(true);
    });

    const canvas = document.getElementById("bgCanvas");
    const ctx = canvas.getContext("2d");
    let width = 0;
    let height = 0;
    let dpr = 1;
    let animationRunning = false;

    function resizeCanvas() {
      width = window.innerWidth;
      height = window.innerHeight;
      dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      if (!reduceMotionQuery.matches) {
        spawnBackground();
      }
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    const particleColors = [
      "rgba(255, 166, 186, 0.55)",
      "rgba(255, 200, 214, 0.5)",
      "rgba(255, 183, 198, 0.55)",
      "rgba(255, 210, 224, 0.45)"
    ];

    const pawColors = [
      "rgba(255, 205, 215, 0.45)",
      "rgba(255, 196, 206, 0.4)"
    ];

    const backgroundParticles = [];
    const burstParticles = [];
    const showerParticles = [];
    let showerActiveUntil = 0;
    let lastShowerSpawn = 0;

    function createBackgroundParticle() {
      const typeRoll = Math.random();
      const type = typeRoll < 0.45 ? "heart" : typeRoll < 0.75 ? "catheart" : "paw";
      const size = 6 + Math.random() * 10;
      return {
        x: Math.random() * width,
        y: Math.random() * height,
        vx: (Math.random() - 0.5) * 0.25,
        vy: -(0.2 + Math.random() * 0.45),
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.012,
        size,
        type,
        alpha: 0.45 + Math.random() * 0.35,
        color: type === "paw" ? pawColors[Math.floor(Math.random() * pawColors.length)] : particleColors[Math.floor(Math.random() * particleColors.length)]
      };
    }

    function resetBackgroundParticle(particle) {
      particle.x = Math.random() * width;
      particle.y = height + Math.random() * height * 0.2;
      particle.vx = (Math.random() - 0.5) * 0.25;
      particle.vy = -(0.2 + Math.random() * 0.45);
      particle.rotation = Math.random() * Math.PI * 2;
      particle.size = 6 + Math.random() * 10;
    }

    function drawHeart(ctxRef, size) {
      ctxRef.save();
      ctxRef.translate(0, -size * 0.45);
      ctxRef.beginPath();
      ctxRef.moveTo(0, size * 0.25);
      ctxRef.bezierCurveTo(0, 0, -size * 0.5, 0, -size * 0.5, size * 0.25);
      ctxRef.bezierCurveTo(-size * 0.5, size * 0.6, 0, size * 0.8, 0, size);
      ctxRef.bezierCurveTo(0, size * 0.8, size * 0.5, size * 0.6, size * 0.5, size * 0.25);
      ctxRef.bezierCurveTo(size * 0.5, 0, 0, 0, 0, size * 0.25);
      ctxRef.closePath();
      ctxRef.fill();
      ctxRef.restore();
    }

    function drawCatHeart(ctxRef, size) {
      drawHeart(ctxRef, size);
      ctxRef.save();
      ctxRef.translate(0, -size * 0.45);
      const ear = size * 0.22;
      ctxRef.beginPath();
      ctxRef.moveTo(-size * 0.22, size * 0.05);
      ctxRef.lineTo(-size * 0.22 - ear * 0.55, -ear);
      ctxRef.lineTo(-size * 0.22 + ear * 0.55, -ear);
      ctxRef.closePath();
      ctxRef.moveTo(size * 0.22, size * 0.05);
      ctxRef.lineTo(size * 0.22 - ear * 0.55, -ear);
      ctxRef.lineTo(size * 0.22 + ear * 0.55, -ear);
      ctxRef.closePath();
      ctxRef.fill();
      ctxRef.restore();
    }

    function drawPaw(ctxRef, size) {
      const pad = size * 0.32;
      const toe = size * 0.18;
      ctxRef.beginPath();
      ctxRef.arc(0, size * 0.12, pad, 0, Math.PI * 2);
      ctxRef.fill();
      const toes = [
        [-size * 0.35, -size * 0.2],
        [-size * 0.12, -size * 0.33],
        [size * 0.12, -size * 0.33],
        [size * 0.35, -size * 0.2]
      ];
      ctxRef.beginPath();
      toes.forEach((point) => {
        ctxRef.moveTo(point[0] + toe, point[1]);
        ctxRef.arc(point[0], point[1], toe, 0, Math.PI * 2);
      });
      ctxRef.fill();
    }

    function drawFlower(ctxRef, size) {
      const petal = size * 0.38;
      ctxRef.save();
      for (let i = 0; i < 5; i += 1) {
        const angle = (Math.PI * 2 * i) / 5;
        ctxRef.beginPath();
        ctxRef.arc(Math.cos(angle) * petal, Math.sin(angle) * petal, petal, 0, Math.PI * 2);
        ctxRef.fill();
      }
      ctxRef.beginPath();
      ctxRef.arc(0, 0, petal * 0.7, 0, Math.PI * 2);
      ctxRef.fill();
      ctxRef.restore();
    }

    function drawParticle(particle) {
      ctx.save();
      ctx.translate(particle.x, particle.y);
      ctx.rotate(particle.rotation);
      ctx.globalAlpha = particle.alpha;
      ctx.fillStyle = particle.color;
      if (particle.type === "paw") {
        drawPaw(ctx, particle.size);
      } else if (particle.type === "flower") {
        drawFlower(ctx, particle.size);
      } else if (particle.type === "catheart") {
        drawCatHeart(ctx, particle.size);
      } else {
        drawHeart(ctx, particle.size);
      }
      ctx.restore();
    }

    function spawnBackground() {
      backgroundParticles.length = 0;
      const count = Math.min(60, Math.floor(width / 12));
      for (let i = 0; i < count; i += 1) {
        backgroundParticles.push(createBackgroundParticle());
      }
    }

    function spawnBurst(x, y) {
      if (reduceMotionQuery.matches) {
        return;
      }
      const count = 18;
      for (let i = 0; i < count; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2.2 + Math.random() * 2.6;
        const size = 6 + Math.random() * 6;
        burstParticles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 1.2,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.25,
          size,
          type: Math.random() < 0.5 ? "heart" : "catheart",
          alpha: 0.95,
          life: 70 + Math.random() * 20,
          maxLife: 90,
          color: particleColors[Math.floor(Math.random() * particleColors.length)]
        });
      }
    }

    function spawnBurstFromYes() {
      const rect = yesBtn.getBoundingClientRect();
      const x = rect.left + rect.width / 2;
      const y = rect.top + rect.height / 2;
      spawnBurst(x, y);
    }

    function startShower() {
      if (isReducedMotion) {
        return;
      }
      showerActiveUntil = performance.now() + 6500;
      lastShowerSpawn = 0;
    }

    function clearShower() {
      showerActiveUntil = 0;
      showerParticles.length = 0;
    }

    function createShowerParticle() {
      const typeRoll = Math.random();
      const type = typeRoll < 0.45 ? "heart" : typeRoll < 0.7 ? "flower" : "catheart";
      const size = 10 + Math.random() * 10;
      return {
        x: Math.random() * width,
        y: -20 - Math.random() * height * 0.15,
        vx: (Math.random() - 0.5) * 0.6,
        vy: 1.4 + Math.random() * 1.8,
        drift: 0.02 + Math.random() * 0.02,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.08,
        size,
        type,
        alpha: 0.95,
        life: 240 + Math.random() * 120,
        maxLife: 360,
        color: particleColors[Math.floor(Math.random() * particleColors.length)]
      };
    }

    function updateShower(now) {
      if (now < showerActiveUntil) {
        const spawnInterval = 70;
        if (now - lastShowerSpawn > spawnInterval) {
          lastShowerSpawn = now;
          const count = 3 + Math.floor(Math.random() * 3);
          for (let i = 0; i < count; i += 1) {
            showerParticles.push(createShowerParticle());
          }
        }
      }

      for (let i = showerParticles.length - 1; i >= 0; i -= 1) {
        const particle = showerParticles[i];
        particle.x += particle.vx + Math.sin(particle.y * 0.02) * particle.drift;
        particle.y += particle.vy;
        particle.vy += 0.01;
        particle.rotation += particle.rotationSpeed;
        particle.life -= 1;
        particle.alpha = Math.max(0, particle.life / particle.maxLife);
        drawParticle(particle);
        if (particle.life <= 0 || particle.y > height + particle.size * 2) {
          showerParticles.splice(i, 1);
        }
      }
    }

    function animate() {
      if (reduceMotionQuery.matches) {
        animationRunning = false;
        return;
      }
      animationRunning = true;
      ctx.clearRect(0, 0, width, height);
      const now = performance.now();

      backgroundParticles.forEach((particle) => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.rotation += particle.rotationSpeed;
        if (particle.y < -particle.size * 2 || particle.x < -particle.size * 2 || particle.x > width + particle.size * 2) {
          resetBackgroundParticle(particle);
        }
        drawParticle(particle);
      });

      for (let i = burstParticles.length - 1; i >= 0; i -= 1) {
        const particle = burstParticles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.02;
        particle.rotation += particle.rotationSpeed;
        particle.life -= 1;
        particle.alpha = Math.max(0, particle.life / particle.maxLife);
        drawParticle(particle);
        if (particle.life <= 0) {
          burstParticles.splice(i, 1);
        }
      }

      updateShower(now);

      requestAnimationFrame(animate);
    }

    if (!reduceMotionQuery.matches) {
      spawnBackground();
      animate();
    }

    reduceMotionQuery.addEventListener("change", (event) => {
      isReducedMotion = event.matches;
      if (event.matches) {
        body.classList.add("reduce-motion");
        tiltCards.forEach((card) => {
          card.style.setProperty("--tilt-x", "0deg");
          card.style.setProperty("--tilt-y", "0deg");
        });
        clearShower();
      } else {
        body.classList.remove("reduce-motion");
        spawnBackground();
        if (!animationRunning) {
          requestAnimationFrame(animate);
        }
      }
    });
  </script>
</body>
</html>
